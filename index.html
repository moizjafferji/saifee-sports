/** === Admin Receipts APIs (Drive upload; image required; stricter required fields) === */

function Receipts_listForAdmin(its){
  const sports = _getObjects(CFG.TABS.ADMINS)
    .filter(r => String(r.its)===String(its))
    .map(r=>r.sport);

  const events = _getObjects(CFG.TABS.EVENTS)
  .filter(e => sports.includes(e.sport))
  .sort((a,b) =>
    new Date(b.created_at || b.start_datetime || 0) -
    new Date(a.created_at || a.start_datetime || 0)
  )
  .map(e => ({
    id: e.id,
    label: `${e.sport || ''} - ${e.name || 'Untitled'} - ${e.start_datetime ? new Date(e.start_datetime).toLocaleString() : ''}`
  }));


  return { events };
}

function Receipts_save(its, payload){
  if (!payload) throw new Error('Missing payload');
  if (!payload.event_id) throw new Error('Missing event_id');

  const events = _getObjects(CFG.TABS.EVENTS);
  const evt = events.find(e => String(e.id)===String(payload.event_id));
  if (!evt) throw new Error('Event not found');

  const sports = _getObjects(CFG.TABS.ADMINS)
    .filter(r => String(r.its)===String(its))
    .map(r=>r.sport);

  if (!sports.includes(evt.sport)) throw new Error('Not authorized for this sport');

  // Required fields (except notes)
  const amt = Number(payload.amount);
  if (!(amt>=0)) throw new Error('Amount must be 0 or more');
  if (!payload.category) throw new Error('Category is required');
  if (!payload.receipt_date) throw new Error('Receipt date is required');

  if (!payload.imageDataUrl || String(payload.imageDataUrl).indexOf('base64,')<0){
    throw new Error('Receipt image is required.');
  }

  const folderId = PropertiesService.getScriptProperties().getProperty('RECEIPTS_FOLDER_ID');
  if (!folderId) throw new Error('Missing Script Property: RECEIPTS_FOLDER_ID');

  const root = DriveApp.getFolderById(folderId);
  const it = root.getFoldersByName(String(payload.event_id));
  const folder = it.hasNext() ? it.next() : root.createFolder(String(payload.event_id));

  const parts = String(payload.imageDataUrl).split(',');
  const meta = parts[0];
  const b64 = parts.slice(1).join(',');
  const mime = (meta.match(/^data:([^;]+);base64$/) || [])[1] || 'application/octet-stream';
  const bytes = Utilities.base64Decode(b64);
  const ext =
    (mime.includes('png') && '.png') ||
    (mime.includes('jpeg') && '.jpg') ||
    (mime.includes('pdf') && '.pdf') || '';

  const blob = Utilities.newBlob(bytes, mime, 'receipt_'+payload.event_id+'_'+Date.now()+ext);
  const file = folder.createFile(blob);
  try { file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW); } catch(e) {}
  const receipt_url = 'https://drive.google.com/uc?export=view&id=' + file.getId();

  const rec = {
    id: null,
    event_id: String(payload.event_id),
    amount: amt,
    category: payload.category || 'Other',
    notes: payload.notes || '',
    receipt_url: receipt_url,
    uploaded_by_its: String(its),
    uploaded_at: nowIso(),
    receipt_date: payload.receipt_date || ''
  };

  const id = _appendObject(CFG.TABS.RECEIPTS, rec);
  return { ok:true, id, url:receipt_url };
}

/** === NEW: Admin-triggered early finalization for a single event ===
 *  - Posts the SAME "final" amounts that the cron would post 5 days after start.
 *  - Safe to run multiple times; cron will still run later and adjust if receipts change.
 */
function Receipts_finalizeNow(its, event_id){
  if (!event_id) throw new Error('Missing event_id');

  // Validate event + permissions
  const events = _getObjects(CFG.TABS.EVENTS);
  const evt = events.find(e => String(e.id)===String(event_id));
  if (!evt) throw new Error('Event not found');

  const sports = _getObjects(CFG.TABS.ADMINS)
    .filter(r => String(r.its)===String(its))
    .map(r=>r.sport);
  if (!sports.includes(evt.sport)) throw new Error('Not authorized for this sport');

  // Build inputs identical to the cron
  const receipts = _getObjects(CFG.TABS.RECEIPTS);
  const capacity = Number(evt.max_capacity||0) || 0;
  const categoryLabel = Event_buildLabel_(evt);

  const people = Registrations_expand_(evt.id, capacity);
  const actives    = people.filter(p => p.status==='active');
  const dropouts   = people.filter(p => p.status==='dropout');
  const waitlisted = people.filter(p => p.status==='waitlist');

  const activeCount     = actives.length;
  const activeBillable  = (capacity > 0 && activeCount >= capacity) ? capacity : activeCount;
  const denom           = activeBillable + dropouts.length;
  if (denom === 0) return { ok:false, message:'No billable attendees for this event.' };

  const total = receipts
    .filter(rc => String(rc.event_id)===String(evt.id))
    .reduce((a, rc) => a + Number(rc.amount||0), 0);

  const shareRaw     = total / denom;
  const shareRounded = Math.round((shareRaw + Number.EPSILON) * 100) / 100;

  // Upsert "posted" transactions for actives + dropouts
  [].concat(actives, dropouts).forEach(p => {
    const txnNo = 'REG:'+p.regId;
    const existing = Txn_findByEventAndTxnNo_(evt.id, txnNo);
    if (existing) {
      _updateWhere(CFG.TABS.TRANSACTIONS,
        t => String(t.event_id)===String(evt.id) && String(t.transaction_number)===txnNo,
        {
          amount: shareRounded,
          status: 'posted',
          category: categoryLabel,
          memo: 'Final amount for '+p.display
        }
      );
    } else {
      Txn_append_({
        its: p.billITS,
        type: 'debit',
        amount: shareRounded,
        source: 'system',
        event_id: String(evt.id),
        category: categoryLabel,
        status: 'posted',
        transaction_number: txnNo,
        memo: 'Final amount for '+p.display
      });
    }
  });

  // Void any waitlist pending items
  waitlisted.forEach(p => {
    const txnNo = 'REG:'+p.regId;
    const existing = Txn_findByEventAndTxnNo_(evt.id, txnNo);
    if (existing && String(existing.status).toLowerCase()!=='void'){
      Txn_voidByTxnNo_(evt.id, txnNo, 'Voided at finalization (waitlist)');
    }
  });

  // Void any other unrelated pendings for this event
  const billableTxnNos = new Set([].concat(actives, dropouts).map(p => 'REG:'+p.regId));
  _updateWhere(CFG.TABS.TRANSACTIONS,
    t => String(t.event_id)===String(evt.id) &&
         String(t.status).toLowerCase()==='pending' &&
         !billableTxnNos.has(String(t.transaction_number)),
    { status: 'void', memo:'Voided (non-billable at finalization)' }
  );

  return {
    ok: true,
    event_id: String(evt.id),
    amount: shareRounded,
    totalReceipts: total,
    denom,
    posted: actives.length + dropouts.length
  };
}

// Alias for older "api_*" naming (keeps callServer fallback working)
function api_receipts_finalizeNow(its, event_id){
  return Receipts_finalizeNow(its, event_id);
}
